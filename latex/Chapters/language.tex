%!TEX root = ../main.tex

% TODO box delle sintassi

\myChapter{LAPSA}
\section{Sintassi}
Per descrivere la sintassi \ac{lapsa} sarà utilizzato il formalismo \emph{EBNF} indicando con le parole in corsivo i simboli non terminali e con quelle in neretto e quelle in stampatello i non terminali. Le parole in neretto sono \emph{keyword} del linguaggio mentre quelle in stampatello descrivono dei valori arbitrari su insiemi come nomi di variabili o costanti numeriche.

Procederemo con la descrizione informale di cosa viene identificato con i costrutti sintattici del linguaggio introducendoli gradualmente. Il non terminale \emph{program} è il simbolo iniziale della grammatica e nella sua struttura racchiude la dichiarazione dell'insieme di azioni considerato, il modulo che descrive il comportamento del soggetto, i moduli che possono essere usati per descrivere l'ambiente e i dati necessari alla discretizzazione delle variabili (tabella \ref{tab:lapsaProgram}).

\begin{table}[htbp!] % sintassi programma LAPSA
$$
\begin{array}{rcl}
	\mathit{program} &::=& \mathbf{actions} \{ \mathit{actions} \} \\
		&& \mathbf{subject} \Space \mathit{module} \\
		&& \mathit{modules} \\
		&& \mathit{environment} \\
		&& \mathbf{ranges} \{ \mathit{ranges} \} \\
\end{array}
$$
\caption{Sintassi \ac{lapsa} di \emph{program}}
\label{tab:lapsaProgram}
\end{table}

Il non terminale \emph{actions} è una semplice lista dove vengono dichiarate i nomi delle azioni che possono essere effettuate (tabella \ref{tab:lapsaActions}). Ovviamente le azioni utilizzate in seguito nelle transizioni dei moduli e nelle sincronizzazioni dovranno essere state dichiarate in questa sezione per considerare il programma \emph{corretto}.

\begin{table}[htbp!] % sintassi azioni LAPS
$$
\begin{array}{rcl}
	\mathit{actions} &::=& \x{action}\textrm{-}\x{id} \Sep \mathit{actions} \Space \mathit{actions} \\
\end{array}
$$
\caption{Sintassi \ac{lapsa} di \emph{actions}}
\label{tab:lapsaActions}
\end{table}

% discorso modulo
La definizione di un comportamento viene espressa tramite il non terminale \emph{module} che permette di descrivere i suoi dati, le sue transizioni e i suoi obiettivi (tabella \ref{tab:lapsaModule}). I dati sono rappresentati dalla lista \emph{variables} e ogni dato è rappresentato dal tipo di dato, il nome associato e l'espressione che gli attribuisce un valore iniziale. Con il non terminale \emph{rules}, invece, viene descritta una lista di transizioni. Le transizioni vengono definite come la tripla \emph{condizione}, \emph{azione}, \emph{distribuzione}: se la condizione è vera allora può essere effettuata l'azione e l'aggiornamento dello stato secondo la distribuzione di probabilità. Gli obiettivi vengono descritti nella lista \emph{targets} dove il primo criterio ha importanza massima e decrementa fino all'ultimo che sarà il meno importante.

\begin{table}[htbp!] % sintassi modulo LAPSA
$$
\begin{array}{rcl}
	\mathit{module} &::=& \mathbf{module} \Space \x{module}\textrm{-}\x{id} \{ \mathit{variables} \Space \mathit{rules} \Space \mathit{targets} \}
		\\[.3cm]
	\mathit{variables} &::=& \x{type} \Space \x{variable}\textrm{-}\x{id} = \mathit{expression}; \Sep \mathit{variables} \Space \mathit{variables}
		\\[.3cm]
	\mathit{rules} &::=& \mathit{condition} [ \x{action}\textrm{-}\x{id}] => \mathit{distribution} \Sep \mathit{rules};\mathit{rules}
		\\[.3cm]
	\mathit{targets} &::=& \mathbf{target} \Space (\mathbf{never} \sep \mathbf{minimize}) \mathit{condition} \Sep \mathit{targets} \Space \mathit{targets} \\
\end{array}
$$
\caption{Sintassi \ac{lapsa} di \emph{module} e delle sezioni che lo compongono}
\label{tab:lapsaModule}
\end{table}

Il non terminale \emph{modules} descritto, assieme ad \emph{environment}, in tabella \ref{tab:lapsaModules} viene utilizzato per definire un insieme di moduli che poi potranno essere istanziati nell'ambiente con dei riferimenti al loro nome. Questo accade all'interno del non terminale \emph{environment} dove viene descritto l'ambiente come una lista di riferimenti a moduli intervallati dagli insiemi di azioni su cui possono sincronizzarsi, un operatore che riprende sintatticamente e semanticamente dal parallelo di Hoare in \ac{csp} \cite{Hoare:1978:CSP}.

\begin{table}[htbp!] % sintassi della definizione dei moduli e dell'ambiente in LAPSA
$$
\begin{array}{rcl}
	\mathit{modules} &::=& \mathit{module} \Sep \mathit{modules} \Space \mathit{modules}
		\\[.3cm]
	\mathit{environment} &::=& \x{module}\textrm{-}\x{id} \Sep \mathit{environment} \Par{\{\mathit{actions}\}} \mathit{environment}
		\\
\end{array}
$$
\caption{Sintassi \ac{lapsa} di \emph{modules} e di \emph{environment}}
\label{tab:lapsaModules}
\end{table}

% continuare
Una regola, invece, è composta da una condizione di guarda che la abilita, un'azione da eseguire, e una distribuzione di possibli funzioni di \emph{update}, ognuna delle quali ha associata una probabilità di essere eseguita. Le probabilità della distribuzione vengono determinate dalla normalizzazione dei pesi associati alle funzioni. La funzione \emph{update} è una sequenza di azioni di aggiornamento di stato o di visione dell'ambiente.

\begin{itemize}
	\item $A$
	\item $\Join$
	\item $\x{id}$
	\item $\x{module}\textrm{-}\x{name}$
	\item $\x{action}\textrm{-}\x{label}$
	\item $\x{type}$
	\item $\x{value}$
\end{itemize}

\begin{table} % sintassi completa LAPSA
	$$
	\begin{array}{|rcl|}
	\hline
	\mathit{program} &::=& \mathbf{actions} \{ \mathit{actions} \} \\
		&& \mathbf{subject} \Space \mathit{module} \\
		&& \mathit{modules} \\
		&& \mathit{environment} \\
		&& \mathbf{ranges} \{ \mathit{ranges} \}
		\\[.3cm]
	\mathit{actions} &::=& \x{action}\textrm{-}\x{id} \Sep \mathit{actions} \Space \mathit{actions}
		\\[.3cm]
	\mathit{targets} &::=& \mathbf{target} \Space (\mathbf{never} \sep \mathbf{minimize}) \mathit{condition}  \\
		& \Sep & \mathit{targets} \Space \mathit{targets}
		\\[.3cm]
	\mathit{modules} &::=& \mathit{module} \Sep \mathit{modules} \Space \mathit{modules}
		\\[.3cm]
	\mathit{environment} &::=& \x{module}\textrm{-}\x{id} \Sep \mathit{environment} \Par{\{\mathit{actions}\}} \mathit{environment}
		\\[.3cm]
	\mathit{module} &::=& \mathbf{module} \Space \x{module}\textrm{-}\x{id} \{ \mathit{variables} \Space \mathit{rules} \}
		\\[.3cm]
	\mathit{variables} &::=& \x{type} \Space \x{variable}\textrm{-}\x{id} = \mathit{expression}; \Sep \mathit{variables} \Space \mathit{variables}
		\\[.3cm]
	\mathit{rules} &::=& \mathit{condition} [ \x{action}\textrm{-}\x{id}] => \mathit{distribution} \Sep \mathit{rules};\mathit{rules}
		\\[.3cm]
	\mathit{condition} &::=& \mathbf{exists} \Space \x{variable}\textrm{-}\x{id}:\x{module}\textrm{-}\x{id} \Space \mathbf{such}\Space\mathbf{that} \Space \mathit{condition} \\
		& \Sep & \mathit{expression} \Join \mathit{expression} \Sep \mathbf{true} \\
		& \Sep & \mathit{condition} \Space \mathbf{or} \Space \mathit{condition} \Sep \mathbf{not} \Space \mathit{condition}
		\\[.3cm]
	\mathit{distribution} &::=& <\mathit{expression}> \mathit{update} \Sep \mathit{distribution} \Space \# \Space \mathit{distribution}
		\\[.3cm]
	\mathit{update} &::=& \x{variable}\textrm{-}\x{id} = \mathit{expression} \Sep \mathbf{noaction} \\
		& \Sep & \mathit{update} \Space , \Space \mathit{update} \Sep \mathbf{env.add} \Space \mathit{system} \\
		& \Sep & \mathbf{env.remove} \Space \x{id}:\x{module}\textrm{-}\x{id} \Space . \Space \mathit{condition} 
		\\[.3cm]
	\mathit{expression} &::=& \mathit{expression} \Space \mathit{bop} \Space \mathit{expression} \Sep \mathit{reference} \Sep \x{constant}
		\\[.3cm]
	\mathit{ranges} &::=& \mathit{reference} \Space \mathbf{in} [\x{constant}, \x{constant}] \Sep \mathit{ranges}, \mathit{ranges}
		\\[.3cm]
	\mathit{reference} &::=& \x{module}\textrm{-}\x{id} \mathbf{.} \x{variable}\textrm{-}\x{id}
		\\[.3cm]
	\mathit{bop} &::=& + \Sep - \Sep * \Sep \slash
		\\
	\hline
	\end{array}
$$
\label{tab:lapsasyntax}
\caption{Sintassi completa di \ac{lapsa}}
\end{table}

L'insieme dei moduli sarà quindi del tipo
$$ M \subseteq \gamma \times \mathbb{VAR} \times \dots \times \mathbb{VAR} $$

\section{Zucchero sintattico}
Inseriamo un costrutto tale da poter inserire una condizione di abilitazione sugli elementi del supporto della distribuzione:
$$
\beta [a]\Rightarrow <e,\beta'> \alpha \oplus \delta
\equiv 
\beta \wedge \beta' [a]\Rightarrow <e> \alpha \oplus \delta,
\beta \wedge \neg\beta' [a]\Rightarrow \delta
$$

\section{Semantica}
Andiamo a dare un'introduzione informale alla semantica del linguaggio descritto:
\begin{itemize}
	\item \emph{System}: un sistema può essere definito tramite un singolo modulo ($m$ è un riferimento alla definizione di un modulo) o attraverso la composizione parallela di più sistemi su di un insieme di azioni di sincronizzazione $A \subseteq Act$;
	\item \emph{Rule}: un insieme di regole definisce il comportamento di un modulo, se vale la condizione $\beta$ si può passare alla valutazione della distribuzione $\delta$;
	\item \emph{Condition}: descrive una condizione fornendo anche un operatore di quantificatore esistenziale sui moduli;
	\item \emph{Distribution}: descrive una distribuzione probabilistica di azioni $\alpha$, dove ogni azione è accompagnata da un'espressione $e$, che ne descrive il peso, e un'azione $a$;
	\item \emph{Action}: un azione descrive un aggiornamento dello stato, che può consistere nell'assegnamento di una, nessuna, o più variabili.
\end{itemize}

Definiamo la semantica del linguaggio in termini di \ac{mdp}. Alla definizione di ogni modulo sarà assegnata una \ac{mdp} della forma:
$$ (\Sigma,Act,\rightarrow_\rho,\sigma_0) $$
dove 
\begin{itemize}
	\item $\Sigma = \{\sigma | \sigma : \mathbb{VAR} \rightarrow \mathbb{VAL}\}$ è l'insieme degli \emph{stati} rappresentati da funzioni che mappano variabili in valori,
	\item $Act$ l'insieme delle azioni,
	\item $\rightarrow_\rho \subseteq \Sigma \times Act \times Dist(U)$ è la relazione di \emph{avanzamento} di stato,
	\item $\sigma_0 \in \Sigma$ è lo \emph{stato iniziale},
	\item $\rho \subseteq \beta \times Act \times Dist(U)$ è la \emph{struttura statica} del \ac{mdp},
	\item $U = \{u | u : \Sigma \rightarrow \Sigma \}$ è l'insieme delle funzioni \emph{update} di aggiornamento di stato.
\end{itemize}

$$
\begin{array}{cl}
	\displaystyle{\frac{(g,a,d) \in \rho}{\sigma \xrightarrow{a}_\rho d(\sigma)} \Space \sigma \models g} & \mbox{(Update)} \\
\end{array}
$$

$$
\rho_m = \{(g,a,d)\ |\ \gamma_m = g[a] \Rightarrow <e_1> \alpha_1 \oplus \cdots \oplus <e_n> \alpha_n, d=[u_{\alpha_{i 1}}:p_1, \dots, u_{\alpha_{i n}}:p_n]\}
$$

dove $u_\alpha \in U$ è una funzione \emph{update} definita nel seguente modo
$$ 
u_{\alpha}(\sigma) = \left\{
\begin{array}{ll}
	\sigma[eval(e)/x]	& \mbox{se } \alpha = x = e; \\
	\sigma				& \mbox{se } \alpha = \mathbf{noaction}; \\
	u_{\alpha''}(u_{\alpha'}(\sigma))	& \mbox{se } \alpha = \alpha' \alpha'' \\
\end{array}
\right.
$$

Le probabilità sono invece calcolate nel seguente modo
$$ p_i = \frac{eval(e_i)}{\sum_{j=1}^{n}eval(e_j)},i=1,\dots,n $$

Salendo dal livello dei moduli a quello dei sistemi, introduciamo $\Pi \in Dist(S) $ per indicare distribuzioni di sistemi. Il sistema sarà rappresentato dalla \ac{mdp} risultante dal parallelo di quelle che lo compongono.

$$
\begin{array}{|cl|}
	\hline
	\displaystyle{\frac{\sigma_m \xrightarrow{a}_{\rho_m} d(\sigma_m)}{S \xrightarrow{a} \Pi}\ m \in S} & \mbox{(Update)} \\[.5cm]
	\displaystyle{\frac{S_1 \xrightarrow{a} \Pi_1 \quad S_2 \xrightarrow{a} \Pi_2}{S_1 \Par{\{\mathit{actions}\}} S_2 \xrightarrow{a} \Pi_1 \Par{\{\mathit{actions}\}} \Pi_2}\ a \in A} & \mbox{(Sync)} \\[.5cm]
	\displaystyle{\frac{S_1 \xrightarrow{a} \Pi_1}{S_1 \Par{\{\mathit{actions}\}} S_2 \xrightarrow{a} \Pi_1 \Par{\{\mathit{actions}\}} S_2}\ a \not\in A} & \mbox{(Async\ 1)} \\[.5cm]
	\displaystyle{\frac{S_2 \xrightarrow{a} \Pi_2}{S_1 \Par{\{\mathit{actions}\}} S_2 \xrightarrow{a} S_1 \Par{\{\mathit{actions}\}} \Pi_2}\ a \not\in A} & \mbox{(Async\ 2)} \\[.5cm]
	\hline
\end{array}
$$

Rimane da definire come si comporta l'operatore di composizione parallela tra un sistema e una distribuzione e tra due distribuzioni.
$$
\Pi_1 \Par{\{\mathit{actions}\}} S_2 (S) = \left\{
\begin{array}{ll}
	\Pi_1(S_1')	& \mbox{se } S = S_1' \Par{\{\mathit{actions}\}} S_2 \\
	0			& \mbox{altrimenti} \\
\end{array}
\right.
$$
$$
S_1 \Par{\{\mathit{actions}\}} \Pi_2 (S) = \left\{
\begin{array}{ll}
	\Pi_2(S_2')	& \mbox{se } S = S_1 \Par{\{\mathit{actions}\}} S_2' \\
	0			& \mbox{altrimenti} \\
\end{array}
\right.
$$
$$
\Pi_1 \Par{\{\mathit{actions}\}} \Pi_2 (S) = \left\{
\begin{array}{ll}
	\Pi_1(S_1)\cdot\Pi_2(S_2)	& \mbox{se } S = S_1 \Par{\{\mathit{actions}\}} S_2 \\
	0			& \mbox{altrimenti} \\
\end{array}
\right.
$$


\section{Esempi}
Esempio di un modulo di robot che esegue una \emph{random walk} su una griglia escludedo dalla scelta probabilistica le direzioni adiacenti occupate:
$$
\begin{array}{rcl}
m_1 () & \triangleq & \mathbf{true} [step]\Rightarrow \\ 
	& & <1, \neg \Space \exists \Space m_1 \Space v: v.x=x \Space \mathbf{and} \Space v.y=y+1> y=y+1; \# \\
	& & <1, \neg \Space \exists \Space m_1 \Space v: v.x=x \Space \mathbf{and} \Space v.y=y-1> y=y-1; \# \\ 
	& & <1, \neg \Space \exists \Space m_1 \Space v: v.x=x+1 \Space \mathbf{and} \Space v.y=y> x=x+1; \# \\ 
	& & <1, \neg \Space \exists \Space m_1 \Space v: v.x=x-1 \Space \mathbf{and} \Space v.y=y> x=x-1; \# \\ 
	& & <1, \mathbf{true}> \mathbf{noaction};\\ 
\end{array}
$$
Esempio di un modulo di robot analogo al precedente con la differenza che la scelta della mossa viene fatta in modo nondeterministico:
$$
\begin{array}{rcllcl}
m_2 () & \triangleq & \neg \Space E \Space m_1 : v . (v.x=x \wedge v.y=y+1) &[north]&\Rightarrow& <1> y=y+1; \\ 
	& & \neg \Space E \Space m_1 : v . (v.x=x \wedge v.y=y-1) &[south]&\Rightarrow& <1> y=y-1; \\ 
	& & \neg \Space E \Space m_1 : v . (v.x=x+1 \wedge v.y=y) &[east]&\Rightarrow& <1> x=x+1; \\ 
	& & \neg \Space E \Space m_1 : v . (v.x=x-1 \wedge v.y=y) &[west]&\Rightarrow& <1> x=x-1; \\ 
	& & \mathbf{true} &[stay]&\Rightarrow& <1> \mathbf{noaction}; \\ 
\end{array}
$$

\section{Da LAPSA a PRISM}
La traduzione del sorgente \ac{lapsa} in codice \prism{} necessita di alcuni dati aggiuntivi riguardo le variabili dei moduli. Dato che \prism{} lavora con uno spazio degli stati finito è necessario aggiungere informazioni che permettano di trattare le variabili intere e reali. Per le variabili intere sarà sufficiente specificare il range, mentre per le variabili reali dovrà essere specificata anche l'ampiezza dell'intervallo di discretizzazione.

La traduzione delle variabili viene descritta in tabella \ref{tab:lapsatoprism}. Con \texttt{a}, \texttt{b} e \texttt{delta} rappresentiamo costanti intere, con \texttt{e} un'espressione \ac{lapsa} e con \texttt{e'} la rispettiva traduzione in \prism{}. I dati necessari alla discretizzazione vengono attualmente forniti direttamente nel file \prism{} nella sezione \emph{ranges}.
\begin{table}[htbp!]
\centering
\begin{tabular}{|l|l|l|}
	\hline
	\ac{lapsa} & \emph{Input file} &\prism{} \\
	\hline
	\texttt{module m\{} & - & \texttt{x:bool init e';} \\
	\texttt{...} & & \\
	\texttt{bool x = e;}  & & \\
	\texttt{...} & & \\
	\texttt{\}} & & \\
	\hline
	\texttt{module m \{} & \texttt{m.y in (a,b);} & \texttt{y:[a..b] init e';} \\
	\texttt{...} & & \\
	\texttt{int y = e;} & & \\
	\texttt{...} & & \\
	\texttt{\}} & & \\
	\hline
	\texttt{module m \{} & \texttt{m.z in (a,b,delta);} & \texttt{z:[0..floor((a-b)/delta)]} \\
	\texttt{...} & & \texttt{init ceil((e'-a)/delta);} \\
	\texttt{float z = e;} & & \\
	\texttt{...} & & \\
	\texttt{\}} & & \\
	\hline
	\texttt{z = e} & \texttt{m.z in (a,b,delta);} & \texttt{z' = ceil((e'-a)/delta)} \\
	\hline
\end{tabular}
\caption{Traduzione da \ac{lapsa} a \prism{}}
\label{tab:lapsatoprism}
\end{table}
