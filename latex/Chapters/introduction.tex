%!TEX root = ../main.tex
\myChapter{Introduzione}

In molti scenari si stanno presentando problematiche inerenti a sistemi dove sono presenti agenti con capacità adattive. In tali sistemi un agente ha, generalmente, una conoscenza parziale del sistema in cui si muove e deve essere in grado di adattarsi alle circostante modificando opportunamente la propria strategia per raggiungere l'obiettivo. Nel progetto ASCENS vengono proposti dei casi di studio dove sono coinvolti tre tipi diversi di agenti di agenti: robot, risorse e e-vehicles \cite{ascens-wp71}. Pur sembrando questi tre scenari molto diversi, essi sono accomunati dalla necessità di descrivere l'interazione tra agenti al fine di raggiungere determinati obiettivi, del singolo o della collettività. Ogni agente è tipicamente a conoscenza delle sue caratteristiche interne ma può non avere a disposizione tutte le informazioni delle altre entità coinvolte e dell'ambiente circostante.

Al fine di evitare ambiguità e di definire con maggior precisione gli obiettivi cerchiamo di rispondere alla domanda ``\emph{in che caso un sistema software si può dire adattivo?}''\cite{concfwada}. 
Diciamo che un sistema software è adattivo quando il suo comportamento e le sue scelte dipendono direttamente da un insieme di \emph{dati di controllo} che possono variare a tempo di esecuzione. Un semplice esempio è un robot che deve arrivare a destinazione senza scontrarsi con altri robot o con ostacoli. L'area circostante il robot viene analizzata dai sensori di prossimità dai quali si potrà ricavare se e dove sono presenti ostacoli e sulla base di queste informazioni il robot potrà stabilire quale sia la direzione migliore da prendere.

Gli scenari che coinvolgono robot sono tipicamente orientati sul comportamento di sciame: obiettivi come l'attraversamento di una buca \cite{adapselfassmaude}
assemblandosi in gruppi richiedono una collaborazione esplicita mentre per la raccolta di risorse \cite{foragingscenarioklaim} o il raggiungimento di una posizione di arrivo comune è sufficiente minimizzare i casi in cui gli agenti si ostacolano a vicenda. Nel caso del cloud computing sono le risorse ad essere viste come gli agenti in gioco e gli obiettivi di interesse possono riguardare la disponibilità e gli aspetti legati alla qualità del servizio. Se consideriamo un insieme di veicoli elettrici (e-vehicles) in grado di comunicare entro un raggio limitato si può pensare a problemi legati all'ottimizzazione del trasporto di persone o oggetti, al traffico, alle disponibilità di parcheggio e alle stazioni di ricarica.

I due aspetti fondamentali comuni in questi scenari sono la comunicazione e la conoscenza limitata dell'ambiente, dove per ambiente si considera tutto quello che è esterno all'agente che osserva. Sono parte dell'ambiente anche gli altri agenti e quindi anche la conoscenza su di essi può essere parziale o nulla.

Quello che si propone è un metodo di risoluzione delle scelte di un agente basato sul \emph{model checking}. L'uso convenzionale dei model checker è mirato alla verifica di proprietà su modelli dei sistemi interessati. Generalmente si ha quindi la conoscenza completa del modello, cosa che non è garantita nel nostro caso. L'idea consiste nel formulare una strategia tramite la quale ipotizzare come si comporterà l'ambiente ed effettuare la verifica su proprietà di interesse. Quando si pone una scelta locale questa può essere risolta valutando la probabilità di raggiungere il nostro obiettivo dallo scenario in cui si arriva compiendo una determinata azione. Quello che viene fatto è quindi una previsione tramite la verifica della proprietà obiettivo sul modello ipotizzato.

Il model checker utilizzato è \prism{} \cite{KNP11}, in quanto in grado di gestire ed analizzare processi stocastici come i \ac{mdp} che sono il principale modello a cui si fa riferimento. \prism{} esegue model checking probabilistico ed è quindi in grado di restituire le probabilità con cui una certa formula viene soddisfatta.

Se prendiamo in considerazione un altro esempio con protagonista un robot che deve rimanere in movimento minimizzando gli scontri con altri robot o ostacoli, possiamo immaginare il sistema composto dal soggetto in parallelo all'ambiente. L'ambiente sarà composto da tutti gli altri robot e ostacoli che il robot adattivo riesce a percepire o di cui ipotizza la presenza. Supponendo che la scelta da prendere riguardi il punto cardinale verso quale muoversi, quello che può essere fatto è utilizzare il model checker per ricavare le probabilità di non scontrarsi con nessuno entro dieci passi nel caso in cui si faccia un passo in una delle quattro direzioni. Avremo così a disposizione una probabilità di successo finale per ogni scelta e sarà sufficiente propendere per quella più alta.

Per realizzare questo approccio è necessario un lavoro di formalizzazione, introduciamo quindi un linguaggio col quale modellare il comportamento dell'agente adattivo. Per questo motivo, introduciamo 
%la specifica di 
\ac{lapsa}, un formalismo per la specifica di agenti adattivi, che permette di modellare i comportamenti tramite moduli descritti come modelli reattivi e mette a disposizione primitive per la gestione della percezione dell'ambiente. L'utilizzatore di \ac{lapsa} può limitarsi alla descrizione del comportamento del soggetto e di come viene gestita la visione dell'ambiente. La compilazione del codice \ac{lapsa} fornirà un modello \prism{} e un file di formule \ac{pctl} sui quali potrà essere eseguito il model checking. A seconda delle potenzialità dell'agente si potrà preveder\`a la possibilt\`a di ri-chamare il model checker da valutare sul momento oppure, in caso di un numero sufficientemente basso di scenari considerati, si potrà fornire del codice precompilato contenente solamente la migliore scelta da fare a seconda dell'ambiente percepito.

Nell'elaborato vente presentata un'implementazione di \ac{lapsa} in \xtext{} \cite{xtext}, un plugin di \eclipse{} che permette lo sviluppo di compilatori per linguaggi completi di un ambiente di sviluppo a supporto. A partire dalla grammatica del linguaggio \xtext{} genera automaticamente funzionalità accessorie legate all'ambiente di sviluppo come auto-completamento e colorazione del codice. Inoltre aggiungendo istruzioni sulla traduzione del codice tramite il linguaggio di template \xtend{} \cite{xtend}
vengono costruiti automaticamente lexer e parser basati su \antlr{} \cite{Parr95antlr:a}.
Raccogliendo tutte queste funzionalità si ottiene un tool installabile come plugin direttamente su \eclipse{}.

Si mostreranno infine i risultati di un semplice caso di studio confrontando i risultati di simulazioni basate su ipotesi di complessità crescente e quelli di approcci na\"{\i}ve.