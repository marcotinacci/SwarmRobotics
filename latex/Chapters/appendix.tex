\appendix
\myChapter{Implementazione di LAPSA in Xtext}\label{app:implementazione}
Il compilatore del linguaggio \ac{lapsa} è stato implementato tramite il tool \xtext{} \cite{xtext} e l'implementazione può essere reperita tramite il repository online \url{https://github.com/marcotinacci/SwarmRobotics}.

Il tool mette a disposizione gli strumenti per definire la grammatica concreta del linguaggio che si vuole tradurre, generando automaticamente tutte le classi \java{} che rappresentano la struttura dei nodi terminali e nonterminali. In questo modo sarà poi possibile implementare il backend facendo riferimento a queste classi ed utilizzandone i metodi visitando l'albero sintattico. La sintassi di \ac{lapsa} è riportata nel listato \ref{code:lapsa:syntax} e segue i costrutti linguistici dati in tabella \ref{tab:lapsaSyntax} ad eccezione di alcune modifiche strettamente legate all'implementazione.

\begin{lstlisting}[language=xtext,style=eclipse,caption={Sintassi di \acs{lapsa} in \xtext{}},label=code:lapsa:syntax]
grammar unifi.marcotinacci.thesis.seal.Seal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate seal "http://www.marcotinacci.unifi/thesis/seal/Seal"

// === main program syntax ===

Program:
	'actions' '{' (actions+=Action)+ '}'
	'subject' modules+=ModuleDefine
	(modules+=ModuleDefine)*
	'environment' ((environment=Environment) | isEmptyEnv?='is empty')
	('ranges' '{' ranges+=Range (',' ranges+=Range)* '}')?
;

Range:
	module=[ModuleDefine] '.' variable=[VariableDeclaration] 'in' '[' from=Value ',' to=Value ']' ('delta' '=' delta=Value)?
;

Action: name=ID ;

// === module syntax ===

ModuleDefine: 
	'module' name=ID '{'
		(variables+=VariableDeclaration ';')+
		(rules+=Rule ';')+
		('target' 'never' never+=Expression)*
	'}'
;

VariableDeclaration:
	type=Type name=ID '=' expr=Expression
;

Type:
	name='int' | name='float' | name='bool'
;

Rule:
	cond=Expression '[' action=[Action] ']' (ndCases+=NDCase)+
;

NDCase:
	'=>' cases+=Case ('#' cases+=Case)*
;

Case:
	'<'weight=Expression (hasCondition?=',' cond=Expression)? '>' update+=Update (',' update+=Update)*
;

Update:
	{ NoAction } 'noaction' | 
	{ Assign } variable=[VariableDeclaration] '=' expr=Expression
;

Environment:
	modules+=[ModuleDefine] ('|{' (actions+=[Action])+ '}|' modules+=[ModuleDefine])*
;


// === expression syntax ===

Expression:
	Logical;

Logical returns Expression:
	Relation
		(({And.left=current} 'and' 
		| {Or.left=current} 'or') 
		right=Relation)*;

Relation returns Expression:
	Addition 
		(({Leq.left=current} '<='
		| {Less.left=current} '<'
		| {Eq.left=current} '=='
		| {Neq.left=current} '!='
		| {Geq.left=current} '>='
		| {Gtr.left=current} '>')
		right=Addition)?;

Addition returns Expression:
	Multiplication 
		(({Plus.left=current} '+' 
		| {Minus.left=current} '-') 
		right=Multiplication)*;

Multiplication returns Expression:
	PrimaryExpression 
		(({Multi.left=current} '*' 
		| {Div.left=current} '/') 
		right=PrimaryExpression)*;

PrimaryExpression returns Expression:
	'(' Expression ')'
	| { Not } 'not' cond=PrimaryExpression
	| { Literal } value=Value
	| { Quantifier } 'exists' name=ID ':' module=[ModuleDefine] 'such that' cond=PrimaryExpression
	| { ExternalReference } module=[Quantifier] '.' variable=[VariableDeclaration] 
	| { LocalReference } ('this' '.')? variable=[VariableDeclaration]   
;

Value: INT | FLOAT | BOOL;

terminal INT returns ecore::EInt: ('0'..'9')+;

terminal FLOAT returns ecore::EDouble:
  ('-')? (INT)* ('.' (INT)+)? |
  ('-')? (INT)+ ('.') | 
  ('-')? (INT)+ ('.' (INT)*)? (('e'|'E')('-'|'+')? (INT)+);

terminal BOOL returns ecore::EBoolean: 'true' | 'false';
\end{lstlisting}

L'implementazione del compilatore avviene attraverso la definizione della funzione \texttt{doGenerate} offerta da \xtext{}. L'implementazione è riportata nel listato \ref{cod:xtend:generate} e consiste nelle fasi principali citate in precedenza: generazione del modello \prism{} e della formula obiettivo \ac{pctl}, esecuzione del model checking ed esportazione dei risultati serializzando la hashtable nel file \texttt{hashtable.ser}.

\begin{lstlisting}[language=xtend,style=eclipse,caption={Implementazione della funzione di generazione in \xtend{}},label=code:xtend:generate]
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		modules = new LinkedList<ModuleDefine>
		renaming = new Hashtable<String, Integer>
		moduleCounter = -1

		var Program p = resource.contents.get(0) as Program
		if(p.isEmptyEnv) env = null
		else env = p.environment

		// prism model generation
		fsa.generateFile("model.pm", p.prismCompile)

		// model checking
		var fh = new FormulaHandler(resource)
		
		moduleCounter = 0
		fh.execModelCheck(p.modules.get(0).never.get(0).prismCompileExpression.toString)
		
		// serialize hashmap
        var objOut = new ObjectOutputStream(
        	new FileOutputStream(Commons::getSrcGenURI(resource)+"hashmtable.ser")
        )
        objOut.writeObject(fh.index);
        objOut.close();
	}
\end{lstlisting}

La generazione del modello \prism{} ha inizio a partire dal nodo iniziale \emph{program} e scende fino alle foglie dell'albero sintattico. All'interno del listato \ref{code:xtend:program} vengono mostrate le funzioni che traducono il nodo \emph{program} e i nodi \emph{module} in condice \prism{}. Nel nodo program viene specificato che si tratta di un modello \ac{mdp} e viene data la traduzione del modulo principale e di quelli dell'ambiente, se ce ne sono. Ogni modulo, a sua volta, viene compilato rimandando la traduzione di ogni nodo \emph{variable} e \emph{rule} che contiene. I nomi delle variabili sono gestiti con un valore numerico incrementale (\texttt{moduleCounter}) in modo da non avere ambiguità.

\begin{lstlisting}[language=xtend,style=eclipse,caption={Generazione dei moduli in \xtend{}},label=code:xtend:program]
	def CharSequence prismCompile(Program p){
		var CharSequence tpl = '''
		mdp
		
		// === MODULES ===
		
		<<p.modules.get(0).prismCompile>>
		'''
		
		if(!p.isEmptyEnv){
			tpl = 
			'''
			<<tpl>>
			<<FOR m:p.environment.modules>>
				<<m.prismCompile>>
			<<ENDFOR>>
			'''
		}
		tpl
	}
		
	def prismCompile(ModuleDefine m){
		moduleCounter=moduleCounter+1
		'''
		module module_<<moduleCounter>>
		// variables
		<<FOR v:m.variables>>
			<<v.prismCompile>>
		<<ENDFOR>>
		// rules
		<<FOR r:m.rules>>
			<<r.prismCompile>>
		<<ENDFOR>>
		endmodule
		'''
	}
\end{lstlisting}

La dichiarazione di variabili viene implementata come descritto nel listato \ref{code:xtend:vars}, recuperando il range dal nodo \emph{ranges} e distinguendo il caso sui tre tipi di variabile che si possono verificare. La variabile booleana ha una mappatura quasi naturale in quanto ci si limita ad aggiungergli solamente la valutazione dell'assegnamento iniziale. Per le variabili intere viene anche specificato il range riportando i valori selezionati. Per gestire le variabili \emph{float} si esegue una discretizzazione: all'interno della sezione \emph{ranges} del file \ac{lapsa} dovranno essere stati specificati i parametri di inizio e fine del dominio e un valore $\delta$ (di default uguale a uno) che specifichi l'ampiezza dell'intervallo di discretizzazione. Il dominio discretizzato viene quindi mappato nel dominio degli interi a partire dallo zero e anche il valore di inizializzazione verrà riadattato allo stesso modo.

\begin{lstlisting}[language=xtend,style=eclipse,caption={Traduzione della dichiarazione di variabili da \acs{lapsa} a \prism{}},label=code:xtend:vars]
	def prismCompile(VariableDeclaration v){
		var from = 0
		var to = 1
		var delta = 1

		// look at ranges and get bounds
		for(r:(v.eContainer.eContainer as Program).ranges){
			if(r.variable==v){
				to = Integer::parseInt(r.to)
				from = Integer::parseInt(r.from)
				if(r.delta != null){
					delta = Integer::parseInt(r.delta)
				}
			}
		}
		'''
		<<v.localName>> : 
		<<IF v.type.name.equals('bool')>>
			bool init <<v.expr.prismCompileExpression>>;
		<<ENDIF>>
		<<IF v.type.name.equals('int')>>
			[<<from>>..<<to>>] init <<v.expr.prismCompileExpression>>;
		<<ENDIF>>
		<<IF v.type.name.equals('float')>>
			[0..floor((<<to>>-<<from>>)/<<delta>>)] init
			ceil((<<v.expr.prismCompileExpression>>-<<from>>)/<<delta>>);
		<<ENDIF>>
		'''
	}
\end{lstlisting}

Come ultima procedura descriviamo la traduzione delle transizioni da \ac{lapsa} a \prism{} (listato \ref{code:xtend:rules}). La condizione di base rappresenta la guardia che abilita la transizione e viene definita una volta inizialmente e riutilizzata se necessario. Può infatti succedere, nel caso in cui utilizziamo il costrutto di scelta nondeterministica, che la condizione debba essere riscritta nel codice \prism{} che non può prevedere quel tipo di espressione. Il primo ciclo scandisce infatti ogni caso nondeterministico e genera una transizione per ciascuno. Il secondo invece si occupa dei casi delle distribuzioni probabilistiche provvisti di guardie generando tutte le combinazioni di condizioni soddisfatte e non. Viene quindi inserita la condizione di base seguita da tutte le condizioni aggiunte dalle dai casi probabilistici provvisti di guardia. Se non ci sono casi allora viene inserita la transizione \emph{true} a probabilità $1$, altrimenti un ulteriore ciclo scandisce i casi presenti. Le probabilità vengono normalizzate in modo che una transizione abbia sempre la distribuzione dei casi a somma $1$, mentre le espressioni di aggiornamento vengono ricavate dai nodi \emph{update}.

\begin{lstlisting}[language=xtend,style=eclipse,caption={Traduzione delle transizioni da \acs{lapsa} a \prism{}},label=code:xtend:rules]
	def prismCompile(Rule r){
		val baseCondition = '''
			[<<r.action.name>>] <<r.cond.prismCompileExpression>>'''
		// add unconditioned cases and true cases
		'''
		<<FOR ndcase:r.ndCases>>
		<<FOR comb:ndcase.cases.reduced.allCombinations 
			SEPARATOR ';' AFTER ';'>>
		<<baseCondition>>
		<<FOR c:ndcase.cases.filter(c|c.hasCondition) 
			BEFORE '&' SEPARATOR '&'>>
			<<IF !comb.contains(c)>>!<<ENDIF>>(<<c.cond.prismCompileExpression>>)
		<<ENDFOR>> 
		-> 
		<<IF comb.size==0 && ndcase.cases.filter(c | !c.hasCondition).size==0>>
			1 : true
		<<ELSE>>
			<<FOR c : ndcase.cases.filter(c | !c.hasCondition 
				|| comb.contains(c)) SEPARATOR '+'>>
				(<<c.weight.prismCompileExpression>>) /
				(<<ndcase.totalWeight(comb)>>) :
				<<FOR u:c.update SEPARATOR '&'>>
					<<u.prismCompileUpdate>>
				<<ENDFOR>>
			<<ENDFOR>>
		<<ENDIF>>
		<<ENDFOR>>
		<<ENDFOR>>
		'''
	}
\end{lstlisting}