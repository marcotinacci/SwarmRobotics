/*
 * generated by Xtext
 */
package unifi.marcotinacci.thesis.seal.generator

import java.io.FileOutputStream
import java.io.ObjectOutputStream
import java.util.Hashtable
import java.util.LinkedList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import unifi.marcotinacci.thesis.seal.seal.And
import unifi.marcotinacci.thesis.seal.seal.Assign
import unifi.marcotinacci.thesis.seal.seal.Case
import unifi.marcotinacci.thesis.seal.seal.Div
import unifi.marcotinacci.thesis.seal.seal.Environment
import unifi.marcotinacci.thesis.seal.seal.Eq
import unifi.marcotinacci.thesis.seal.seal.ExternalReference
import unifi.marcotinacci.thesis.seal.seal.Geq
import unifi.marcotinacci.thesis.seal.seal.Gtr
import unifi.marcotinacci.thesis.seal.seal.Leq
import unifi.marcotinacci.thesis.seal.seal.Less
import unifi.marcotinacci.thesis.seal.seal.Literal
import unifi.marcotinacci.thesis.seal.seal.LocalReference
import unifi.marcotinacci.thesis.seal.seal.Minus
import unifi.marcotinacci.thesis.seal.seal.ModuleDefine
import unifi.marcotinacci.thesis.seal.seal.Multi
import unifi.marcotinacci.thesis.seal.seal.Neq
import unifi.marcotinacci.thesis.seal.seal.NoAction
import unifi.marcotinacci.thesis.seal.seal.Not
import unifi.marcotinacci.thesis.seal.seal.Or
import unifi.marcotinacci.thesis.seal.seal.Plus
import unifi.marcotinacci.thesis.seal.seal.Program
import unifi.marcotinacci.thesis.seal.seal.Quantifier
import unifi.marcotinacci.thesis.seal.seal.Rule
import unifi.marcotinacci.thesis.seal.seal.VariableDeclaration
import unifi.marcotinacci.thesis.seal.utils.Commons
import unifi.marcotinacci.thesis.seal.seal.NDCase

class SealGenerator implements IGenerator {

	private List<ModuleDefine> modules
	private int moduleCounter
	private Hashtable<String,Integer> renaming
	private Environment env  
//	private DataSet ds

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		modules = new LinkedList<ModuleDefine>
		renaming = new Hashtable<String, Integer>
		moduleCounter = -1

		var Program p = resource.contents.get(0) as Program
		if(p.isEmptyEnv) env = null
		else env = p.environment
		// extract dataset
//		ds = new DataSet(p.ranges)

		// prism model generation
		fsa.generateFile("model.pm", p.prismCompile)

		// model checking
		var fh = new FormulaHandler(resource)
		
		moduleCounter = 0
		fh.execModelCheck(p.modules.get(0).never.get(0).prismCompileExpression.toString)
		
		// serialize hashmap
        var objOut = new ObjectOutputStream(
        	new FileOutputStream(Commons::getSrcGenURI(resource)+"hashmap.ser")
        )
        objOut.writeObject(fh.index);
        objOut.close();
	}
	
	def CharSequence prismCompile(Program p){
		var CharSequence tpl = '''
		mdp
		
		// === MODULES ===
		«p.modules.get(0).prismCompile»
		'''
		if(!p.isEmptyEnv){
			tpl = 
			'''
			«tpl»
			«FOR m:p.environment.modules»«m.prismCompile»
			«ENDFOR»
			'''
		}
		tpl
	}
		
	def prismCompile(ModuleDefine m){
		moduleCounter=moduleCounter+1
		'''
		module module_«moduleCounter»
		// variables
		«FOR v:m.variables»
			«v.prismCompile»
		«ENDFOR»
		// rules
		«FOR r:m.rules»
			«r.prismCompile»
		«ENDFOR»
		endmodule
		'''
	}

	def prismCompile(VariableDeclaration v){
		var from = 0
		var to = 1
		var delta = 1

		// look at ranges and get bounds
		for(r:(v.eContainer.eContainer as Program).ranges){
			if(r.variable==v){
				to = Integer::parseInt(r.to)
				from = Integer::parseInt(r.from)
				if(r.delta != null){
					delta = Integer::parseInt(r.delta)
				}
			}
		}

		// TODO risistemare col dataset
		'''«v.localName» : «IF v.type.name.equals('bool')»bool init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('int')»[«from»..«to»] init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('float')»[0..floor((«to»-«from»)/«delta»)] init ceil((«v.expr.prismCompileExpression»-«from»)/«delta»);«ENDIF»'''
	}

	def prismCompile(Rule r){
//		var combinations = r.cases.getReduced.allCombinations
		val baseCondition = '''[«r.action.name»] «r.cond.prismCompileExpression»'''
		// add unconditioned cases and true cases
		'''
		«FOR ndcase:r.ndCases»
			«FOR comb:ndcase.cases.reduced.allCombinations SEPARATOR ';' AFTER ';'»
				«baseCondition»
				«FOR c:ndcase.cases.filter(c|c.hasCondition) BEFORE '&' SEPARATOR '&'»
					«IF !comb.contains(c)»!«ENDIF»(«c.cond.prismCompileExpression»)
				«ENDFOR» -> 
				«IF comb.size == 0 && ndcase.cases.filter(c | !c.hasCondition).size == 0» 1 : true
				«ELSE»
					«FOR c : ndcase.cases.filter(c | !c.hasCondition || comb.contains(c)) SEPARATOR '+'»
						(«c.weight.prismCompileExpression»)/(«ndcase.totalWeight(comb)») : 
						«FOR u:c.update SEPARATOR '&'»
							«u.prismCompileUpdate»
						«ENDFOR»
					«ENDFOR»
				«ENDIF»
			«ENDFOR»
		«ENDFOR»
		'''
	}

	/**
	 * precondition: list 'cases' contains only cases with condition 
	 */
	def List<List<Case>> getAllCombinations(List<Case> cases) {
		// base case, empty list
		var List<List<Case>> combList = newArrayList
		if(cases.isEmpty()){
			combList.add(newArrayList)
			return combList
		}
		
		// recursive call case
		var head = cases.get(0)
		var tail = cases.subList(1, cases.size())
		// TODO avoid recursion
		for(comb : tail.allCombinations){
			var List<Case> newComb = newArrayList
			newComb.add(head)
			newComb.addAll(comb)
			combList.add(comb)
			combList.add(newComb)
		}
		return combList
	}
	
	def List<Case> getReduced(List<Case> cases) {
		var List<Case> reduced = newArrayList
		for(c : cases){
			if(c.hasCondition){
				reduced.add(c)
			}
		}
		return reduced
	}

	def totalWeight(NDCase ndcase, List<Case> comb)
	'''
	«FOR c:ndcase.cases.filter(c | !c.hasCondition || comb.contains(c)) SEPARATOR '+'»
		(«c.weight.prismCompileExpression»)
	«ENDFOR»
	'''
	
	def dispatch prismCompileUpdate (NoAction n) 
	'''true'''

	def dispatch prismCompileUpdate (Assign a)
	'''(«a.variable.localName»'=«a.expr.prismCompileExpression»)'''

	def dispatch prismCompileExpression(And e)
	'''(«e.left.prismCompileExpression» & «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Or e)
	'''(«e.left.prismCompileExpression» | «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Not e)
	'''!(«e.cond.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Leq e)	
	'''(«e.left.prismCompileExpression» <= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Less e)
	'''(«e.left.prismCompileExpression» < «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Geq e)	
	'''(«e.left.prismCompileExpression» >= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Gtr e)
	'''(«e.left.prismCompileExpression» > «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Eq e)
	'''(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Neq e)
	'''!(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Plus e)	
	'''(«e.left.prismCompileExpression» + «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Minus e)
	'''(«e.left.prismCompileExpression» - «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Multi e)
	'''(«e.left.prismCompileExpression» * «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Div e)
	'''(«e.left.prismCompileExpression» / «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Literal e){
		e.value
	}

	def dispatch prismCompileExpression(LocalReference e)
	'''«e.variable.localName»'''

	def dispatch prismCompileExpression(ExternalReference e){
		'''«e.variable.name»_«renaming.get(e.module.name)»'''
	}
	
	def dispatch prismCompileExpression(Quantifier e){
		var i = 1
		var tpl = '''false'''
		for(m : env.modules){
			if(m.name.equals(e.module.name)){
				renaming.put(e.name, i)
				tpl = '''(«tpl» | «e.cond.prismCompileExpression»)'''
				renaming.remove(e.name)
			}
			i=i+1
		}
		tpl
	}

	def localName(VariableDeclaration v)
	'''«v.name»_«moduleCounter»'''

}

