grammar unifi.marcotinacci.thesis.seal.Seal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate seal "http://www.marcotinacci.unifi/thesis/seal/Seal"

// === main program syntax ===

Program:
	'actions' '{' (actions+=Action)* '}'
	(modules+=ModuleDefine)*
	'system' system=System ';'
	('ranges' '{' ranges+=Range (',' ranges+=Range)* '}')?
;

// TODO type check
Range:
	module=[ModuleDefine] '.' variable=[VariableDeclaration] 'in' '[' from=Value ',' to=Value ']' ('delta' '=' delta=Value)?
;

Action: name=ID ;

// === module syntax ===

ModuleDefine: 
	'module' name=ID '{'
		(variables+=VariableDeclaration ';')+
		(rules+=Rule ';')+
	'}'
;

VariableDeclaration:
	type=Type name=ID '=' expr=Expression
;

Type:
	name='int' | name='float' | name='bool'
;

Rule:
	cond=Expression '[' action=[Action] ']' '=>' cases+=Case ('#' cases+=Case)*
;

Case:
	'<'weight=Expression'>' update+=Update (',' update+=Update)*
;

Update:
	{ NoAction } 'noaction' | 
	{ Assign } variable=[VariableDeclaration] '=' expr=Expression
;

// === system syntax ===

System:
	Subsystem ({Parallel.left=current} '||' '{' (actions+=[Action])+ '}' right=Subsystem)*
;

Subsystem returns System:
	'(' System ')' |
	{ SingleModule } module+=[ModuleDefine]
;


// === expression syntax ===

Expression:
	Logical;

Logical returns Expression:
	Relation
		(({And.left=current} 'and' 
		| {Or.left=current} 'or') 
		right=Relation)*;

Relation returns Expression:
	Addition 
		(({Leq.left=current} '<='
		| {Less.left=current} '<'
		| {Eq.left=current} '=='
		| {Neq.left=current} '!='
		| {Geq.left=current} '>='
		| {Gtr.left=current} '>')
		right=Addition)?;

Addition returns Expression:
	Multiplication 
		(({Plus.left=current} '+' 
		| {Minus.left=current} '-') 
		right=Multiplication)*;

Multiplication returns Expression:
	PrimaryExpression 
		(({Multi.left=current} '*' 
		| {Div.left=current} '/') 
		right=PrimaryExpression)*;

PrimaryExpression returns Expression:
	'(' Expression ')'
	// TODO parentesi per disambiguare la sintassi
	| { Not } 'not' cond=PrimaryExpression
	| { Literal } value=Value
	//| { VariableReference } variable=[VariableDeclaration]
	// TODO modificare sintassi quantificatore come segue
	| { Quantifier } 'E' name=ID ':' module=[ModuleDefine] 'st' cond=PrimaryExpression
	| { QuantifierReference } (isLocal?='this' '.' | module=[Quantifier] '.') variable=[VariableDeclaration]   
;

Value: INT | FLOAT | BOOL;

terminal INT returns ecore::EInt: ('0'..'9')+;

terminal FLOAT returns ecore::EDouble: ('0'..'9')* ('.' ('0'..'9')+)?;

terminal BOOL returns ecore::EBoolean: 'true' | 'false';
