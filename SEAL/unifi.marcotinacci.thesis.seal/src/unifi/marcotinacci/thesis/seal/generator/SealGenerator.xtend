/*
 * generated by Xtext
 */
package unifi.marcotinacci.thesis.seal.generator

import java.util.Hashtable
import java.util.LinkedList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import unifi.marcotinacci.thesis.seal.seal.And
import unifi.marcotinacci.thesis.seal.seal.Assign
import unifi.marcotinacci.thesis.seal.seal.Div
import unifi.marcotinacci.thesis.seal.seal.Eq
import unifi.marcotinacci.thesis.seal.seal.ExternalReference
import unifi.marcotinacci.thesis.seal.seal.Geq
import unifi.marcotinacci.thesis.seal.seal.Gtr
import unifi.marcotinacci.thesis.seal.seal.Leq
import unifi.marcotinacci.thesis.seal.seal.Less
import unifi.marcotinacci.thesis.seal.seal.Literal
import unifi.marcotinacci.thesis.seal.seal.LocalReference
import unifi.marcotinacci.thesis.seal.seal.Minus
import unifi.marcotinacci.thesis.seal.seal.ModuleDefine
import unifi.marcotinacci.thesis.seal.seal.Multi
import unifi.marcotinacci.thesis.seal.seal.Neq
import unifi.marcotinacci.thesis.seal.seal.NoAction
import unifi.marcotinacci.thesis.seal.seal.Not
import unifi.marcotinacci.thesis.seal.seal.Or
import unifi.marcotinacci.thesis.seal.seal.Parallel
import unifi.marcotinacci.thesis.seal.seal.Plus
import unifi.marcotinacci.thesis.seal.seal.Program
import unifi.marcotinacci.thesis.seal.seal.Quantifier
import unifi.marcotinacci.thesis.seal.seal.Rule
import unifi.marcotinacci.thesis.seal.seal.SingleModule
import unifi.marcotinacci.thesis.seal.seal.VariableDeclaration
import unifi.marcotinacci.thesis.seal.seal.impl.SealFactoryImpl

class SealGenerator implements IGenerator {
	
	private List<ModuleDefine> modules
	private int moduleCounter
	private Hashtable<String,Integer> renaming
	private DataSet ds
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		modules = new LinkedList<ModuleDefine>()
		renaming = new Hashtable<String, Integer>()
		moduleCounter = -1;
		
		var Program p = resource.contents.get(0) as Program
		// extract dataset
		ds = new DataSet(p.ranges)

		// prism model generation
		fsa.generateFile("model.pm", p.prismCompile)

		// model checking
		var fh = new FormulaHandler(resource)
		fh.execModelCheck("(pos_0 = 4)")
		
		// results convert
		
		// probability extraction
		//getProbability(results, newArrayList(1,1,1,2))
		
		// cpp module generation
		fsa.generateFile("module.cpp", p.cppCompile)
	}
	

	
	def getProbability(String results){
		//var command = '''grep "(«FOR i:indexes SEPARATOR ','»«i»«ENDFOR»)" res.txt | sed "s/.*=//"'''
	}
	

	
	def cppCompile(Program program)
	// STUB
	'''
	#include <iostream>
	using namespace std;
	void main()
	{
		cout << "Hello World!" << endl;
	}
	'''
	
	def prismCompile(Program p){
		p.system.buildModuleList
	'''
	mdp

	// === MODULES ===
	«p.system.prismCompileSystem»
	'''
	}
	
	def dispatch buildModuleList(Parallel p) {
		p.left.buildModuleList
		p.right.buildModuleList
	}
	
	def dispatch buildModuleList(SingleModule m){
		modules.add(m.module)
	}
	
	def dispatch prismCompileSystem(Parallel p){
	'''
	«FOR m:modules»«m.prismCompile»
	«ENDFOR»
	'''
	}
	
	def dispatch prismCompileSystem(SingleModule m){
		m.module.prismCompile
	}
		
	def prismCompile(ModuleDefine m){
	moduleCounter=moduleCounter+1
	'''
	module module_«moduleCounter»
	// variables
	«FOR v:m.variables»
		«v.prismCompile»
	«ENDFOR»
	// rules
	«FOR r:m.rules»
		«r.prismCompile»
	«ENDFOR»
	endmodule
	'''
	}

	def prismCompile(VariableDeclaration v){
		var from = 0
		var to = 1
		var delta = 1
		
		// look at ranges and get bounds
		for(r:(v.eContainer.eContainer as Program).ranges){
			if(r.variable==v){
				to = Integer::parseInt(r.to)
				from = Integer::parseInt(r.from)
				if(r.delta != null){
					delta = Integer::parseInt(r.delta)
				}
			}
		}
		
		// TODO risistemare col dataset
		'''«v.localName» : «IF v.type.name.equals('bool')»bool init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('int')»[«from»..«to»] init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('float')»[0..floor((«to»-«from»)/«delta»)] init ceil((«v.expr.prismCompileExpression»-«from»)/«delta»);«ENDIF»'''
	}

	def prismCompileRec(Rule r){
		var kernelRule = true
		var ret = ''''''
		var i = 0
		while(i < r.cases.size){
			var c = r.cases.get(i)
			if(c.hasCondition){
				// signal the rule is expandible
				kernelRule = false
				// remove the case frome the rule
				r.cases.remove(i)
				// move the case condition to the rule guard
				var temp = r.cond
				r.cond = SealFactoryImpl::eINSTANCE.createAnd()
				(r.cond as And).setLeft(temp)
				(r.cond as And).setRight(c.cond)
				// compile without condition
				ret = '''«ret» «r.prismCompileRec»'''
				// restore
				r.cases.add(i,c)
				r.cond = (r.cond as And).left
				// compile with condition
				ret = '''«ret» «r.prismCompileRec»'''
			}
			i=i+1
		}
		if(kernelRule){
			ret = r.prismCompile
		}
		return ret
	}
	
	def buildCondition(Rule r, int firstCase, CharSequence tpl){
		var i = firstCase
		var kernelRule = true
		while(i < r.cases.size){
			var c = r.cases.get(i)
			if(c.hasCondition){
				// signal the rule is expandible
				kernelRule = false
// TODO
			}
			i=i+1
		}
		if(kernelRule){
			// TODO
		}
		return tpl
	}

	def prismCompile(Rule r)
	'''
	[«r.action.name»] «r.cond.prismCompileExpression» -> 
	«FOR c:r.cases SEPARATOR '+' AFTER ';'»
		(«c.weight.prismCompileExpression»)/(«r.totalWeight») : 
		«FOR u:c.update SEPARATOR '&'»
			«u.prismCompileUpdate»
		«ENDFOR»
	«ENDFOR»
	'''
	
	// TODO calcolare l'espressione concatenata solo una volta
	def totalWeight(Rule r)
	'''«FOR c:r.cases SEPARATOR '+'»(«c.weight.prismCompileExpression»)«ENDFOR»'''
	
	def dispatch prismCompileUpdate (NoAction n) 
	'''true'''

	def dispatch prismCompileUpdate (Assign a)
	'''(«a.variable.localName»'=«a.expr.prismCompileExpression»)'''

	def dispatch prismCompileExpression(And e)
	'''(«e.left.prismCompileExpression» & «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Or e)
	'''(«e.left.prismCompileExpression» | «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Not e)
	'''!(«e.cond.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Leq e)	
	'''(«e.left.prismCompileExpression» <= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Less e)
	'''(«e.left.prismCompileExpression» < «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Geq e)	
	'''(«e.left.prismCompileExpression» >= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Gtr e)
	'''(«e.left.prismCompileExpression» > «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Eq e)
	'''(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Neq e)
	'''!(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Plus e)	
	'''(«e.left.prismCompileExpression» + «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Minus e)
	'''(«e.left.prismCompileExpression» - «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Multi e)
	'''(«e.left.prismCompileExpression» * «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Div e)
	'''(«e.left.prismCompileExpression» / «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Literal e){
		e.value
	}

	def dispatch prismCompileExpression(LocalReference e)
	'''«e.variable.localName»'''	

	def dispatch prismCompileExpression(ExternalReference e){
		'''«e.variable.name»_«renaming.get(e.module.name)»'''
	}
	
	def dispatch prismCompileExpression(Quantifier e){
		var i = 0
		var tpl = '''false'''
		for(m : modules){
			if(m.name.equals(e.module.name)){
				renaming.put(e.name, i)
				tpl = '''(«tpl» | «e.cond.prismCompileExpression»)'''
				renaming.remove(e.name)
			}
			i=i+1
		}
		tpl
	}

	def localName(VariableDeclaration v)
	'''«v.name»_«moduleCounter»'''

}

