/*
 * generated by Xtext
 */
package unifi.marcotinacci.thesis.seal.generator

import java.io.FileOutputStream
import java.io.ObjectOutputStream
import java.util.Hashtable
import java.util.LinkedList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import unifi.marcotinacci.thesis.seal.seal.And
import unifi.marcotinacci.thesis.seal.seal.Assign
import unifi.marcotinacci.thesis.seal.seal.Div
import unifi.marcotinacci.thesis.seal.seal.Eq
import unifi.marcotinacci.thesis.seal.seal.ExternalReference
import unifi.marcotinacci.thesis.seal.seal.Geq
import unifi.marcotinacci.thesis.seal.seal.Gtr
import unifi.marcotinacci.thesis.seal.seal.Leq
import unifi.marcotinacci.thesis.seal.seal.Less
import unifi.marcotinacci.thesis.seal.seal.Literal
import unifi.marcotinacci.thesis.seal.seal.LocalReference
import unifi.marcotinacci.thesis.seal.seal.Minus
import unifi.marcotinacci.thesis.seal.seal.ModuleDefine
import unifi.marcotinacci.thesis.seal.seal.Multi
import unifi.marcotinacci.thesis.seal.seal.Neq
import unifi.marcotinacci.thesis.seal.seal.NoAction
import unifi.marcotinacci.thesis.seal.seal.Not
import unifi.marcotinacci.thesis.seal.seal.Or
import unifi.marcotinacci.thesis.seal.seal.Parallel
import unifi.marcotinacci.thesis.seal.seal.Plus
import unifi.marcotinacci.thesis.seal.seal.Program
import unifi.marcotinacci.thesis.seal.seal.Quantifier
import unifi.marcotinacci.thesis.seal.seal.Rule
import unifi.marcotinacci.thesis.seal.seal.SingleModule
import unifi.marcotinacci.thesis.seal.seal.VariableDeclaration
import unifi.marcotinacci.thesis.seal.seal.impl.SealFactoryImpl
import unifi.marcotinacci.thesis.seal.utils.Commons
import unifi.marcotinacci.thesis.seal.seal.Case
import unifi.marcotinacci.thesis.seal.seal.Environment

class SealGenerator implements IGenerator {

	private List<ModuleDefine> modules
	private int moduleCounter
	private Hashtable<String,Integer> renaming
	private Environment env  
//	private DataSet ds

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		modules = new LinkedList<ModuleDefine>
		renaming = new Hashtable<String, Integer>
		moduleCounter = -1

		var Program p = resource.contents.get(0) as Program
		if(p.isEmptyEnv) env = null
		else env = p.environment
		// extract dataset
//		ds = new DataSet(p.ranges)

		// prism model generation
		fsa.generateFile("model.pm", p.prismCompile)

		// model checking
		var fh = new FormulaHandler(resource)
		fh.execModelCheck("(pos_0 = pos_1)") // STUB
		
		// serialize hashmap
        var objOut = new ObjectOutputStream(
        	new FileOutputStream(Commons::getSrcGenURI(resource)+"hashmap.ser")
        )
        objOut.writeObject(fh.index);
        objOut.close();
	}
	
	def CharSequence prismCompile(Program p){
		var CharSequence tpl = '''
		mdp
		
		// === MODULES ===
		«p.modules.get(0).prismCompile»
		'''
		if(!p.isEmptyEnv){
			p.environment.buildModuleList
			tpl = 
			'''
			«tpl»
			«p.environment.prismCompileSystem»
			'''
		}
		tpl
	}
	
	def dispatch buildModuleList(Parallel p) {
		p.left.buildModuleList
		p.right.buildModuleList
	}
	
	def dispatch buildModuleList(SingleModule m){
		modules.add(m.module)
	}
	
	def dispatch prismCompileSystem(Parallel p){
		'''
		«FOR m:modules»«m.prismCompile»
		«ENDFOR»
		'''
	}
	
	def dispatch prismCompileSystem(SingleModule m){
		m.module.prismCompile
	}
		
	def prismCompile(ModuleDefine m){
		moduleCounter=moduleCounter+1
		'''
		module module_«moduleCounter»
		// variables
		«FOR v:m.variables»
			«v.prismCompile»
		«ENDFOR»
		// rules
		«FOR r:m.rules»
			«r.prismCompile»
		«ENDFOR»
		endmodule
		'''
	}

	def prismCompile(VariableDeclaration v){
		var from = 0
		var to = 1
		var delta = 1

		// look at ranges and get bounds
		for(r:(v.eContainer.eContainer as Program).ranges){
			if(r.variable==v){
				to = Integer::parseInt(r.to)
				from = Integer::parseInt(r.from)
				if(r.delta != null){
					delta = Integer::parseInt(r.delta)
				}
			}
		}

		// TODO risistemare col dataset
		'''«v.localName» : «IF v.type.name.equals('bool')»bool init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('int')»[«from»..«to»] init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('float')»[0..floor((«to»-«from»)/«delta»)] init ceil((«v.expr.prismCompileExpression»-«from»)/«delta»);«ENDIF»'''
	}

	def prismCompileRec(Rule r){
		var kernelRule = true
		var ret = ''''''
		var i = 0
		while(i < r.cases.size){
			var c = r.cases.get(i)
			if(c.hasCondition){
				// signal the rule is expandible
				kernelRule = false
				// remove the case frome the rule
				r.cases.remove(i)
				// move the case condition to the rule guard
				var temp = r.cond
				r.cond = SealFactoryImpl::eINSTANCE.createAnd()
				(r.cond as And).setLeft(temp)
				(r.cond as And).setRight(c.cond)
				// compile without condition
				ret = '''«ret» «r.prismCompileRec»'''
				// restore
				r.cases.add(i,c)
				r.cond = (r.cond as And).left
				// compile with condition
				ret = '''«ret» «r.prismCompileRec»'''
			}
			i=i+1
		}
		if(kernelRule){
			ret = r.prismCompile
		}
		return ret
	}
	
	def buildCondition(Rule r, int firstCase, CharSequence tpl){
		var i = firstCase
		var kernelRule = true
		while(i < r.cases.size){
			var c = r.cases.get(i)
			if(c.hasCondition){
				// signal the rule is expandible
				kernelRule = false
// TODO
			}
			i=i+1
		}
		if(kernelRule){
			// TODO
		}
		return tpl
	}

	def prismCompile(Rule r){
		var combinations = r.cases.getReduced.allCombinations
		val baseCondition = '''[«r.action.name»] «r.cond.prismCompileExpression»'''
		// add unconditioned cases and true cases
		'''
		«FOR comb:combinations SEPARATOR ';' AFTER ';'»
			«baseCondition»
			«FOR c:r.cases.filter(c|c.hasCondition) BEFORE '&' SEPARATOR '&'»
				«IF !comb.contains(c)»!«ENDIF»(«c.cond.prismCompileExpression»)
			«ENDFOR» -> 
			«IF comb.size == 0 && r.cases.filter(c | !c.hasCondition).size == 0» 1 : true
			«ELSE»
				«FOR c : r.cases.filter(c | !c.hasCondition || comb.contains(c)) SEPARATOR '+'»
					(«c.weight.prismCompileExpression»)/(«r.totalWeight(comb)») : 
					«FOR u:c.update SEPARATOR '&'»
						«u.prismCompileUpdate»
					«ENDFOR»
				«ENDFOR»
			«ENDIF»
		«ENDFOR»
		'''
	}

	/**
	 * precondition: list 'cases' contains only cases with condition 
	 */
	def List<List<Case>> getAllCombinations(List<Case> cases) {
		// base case, empty list
		var List<List<Case>> combList = newArrayList
		if(cases.isEmpty()){
			combList.add(newArrayList)
			return combList
		}
		
		// recursive call case
		var head = cases.get(0)
		var tail = cases.subList(1, cases.size())
		// TODO avoid recursion
		for(comb : tail.allCombinations){
			var List<Case> newComb = newArrayList
			newComb.add(head)
			newComb.addAll(comb)
			combList.add(comb)
			combList.add(newComb)
		}
		return combList
	}
	
	def List<Case> getReduced(List<Case> cases) {
		var List<Case> reduced = newArrayList
		for(c : cases){
			if(c.hasCondition){
				reduced.add(c)
			}
		}
		return reduced
	}

		
	// TODO calcolare l'espressione concatenata solo una volta
	def totalWeight(Rule r)
	'''«FOR c:r.cases SEPARATOR '+'»(«c.weight.prismCompileExpression»)«ENDFOR»'''
	
	def totalWeight(Rule r, List<Case> comb)
	'''
	«FOR c:r.cases.filter(c | !c.hasCondition || comb.contains(c)) SEPARATOR '+'»
		(«c.weight.prismCompileExpression»)
	«ENDFOR»
	'''
	
	def dispatch prismCompileUpdate (NoAction n) 
	'''true'''

	def dispatch prismCompileUpdate (Assign a)
	'''(«a.variable.localName»'=«a.expr.prismCompileExpression»)'''

	def dispatch prismCompileExpression(And e)
	'''(«e.left.prismCompileExpression» & «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Or e)
	'''(«e.left.prismCompileExpression» | «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Not e)
	'''!(«e.cond.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Leq e)	
	'''(«e.left.prismCompileExpression» <= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Less e)
	'''(«e.left.prismCompileExpression» < «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Geq e)	
	'''(«e.left.prismCompileExpression» >= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Gtr e)
	'''(«e.left.prismCompileExpression» > «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Eq e)
	'''(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Neq e)
	'''!(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Plus e)	
	'''(«e.left.prismCompileExpression» + «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Minus e)
	'''(«e.left.prismCompileExpression» - «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Multi e)
	'''(«e.left.prismCompileExpression» * «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Div e)
	'''(«e.left.prismCompileExpression» / «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Literal e){
		e.value
	}

	def dispatch prismCompileExpression(LocalReference e)
	'''«e.variable.localName»'''

	def dispatch prismCompileExpression(ExternalReference e){
		'''«e.variable.name»_«renaming.get(e.module.name)»'''
	}
	
	def dispatch prismCompileExpression(Quantifier e){
		var i = 0
		var tpl = '''false'''
		for(m : modules){
			if(m.name.equals(e.module.name)){
				renaming.put(e.name, i)
				tpl = '''(«tpl» | «e.cond.prismCompileExpression»)'''
				renaming.remove(e.name)
			}
			i=i+1
		}
		tpl
	}

	def localName(VariableDeclaration v)
	'''«v.name»_«moduleCounter»'''

}

