/*
 * generated by Xtext
 */
package unifi.marcotinacci.thesis.seal.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import unifi.marcotinacci.thesis.seal.seal.And
import unifi.marcotinacci.thesis.seal.seal.Assign
import unifi.marcotinacci.thesis.seal.seal.Div
import unifi.marcotinacci.thesis.seal.seal.Eq
import unifi.marcotinacci.thesis.seal.seal.Geq
import unifi.marcotinacci.thesis.seal.seal.Gtr
import unifi.marcotinacci.thesis.seal.seal.Leq
import unifi.marcotinacci.thesis.seal.seal.Less
import unifi.marcotinacci.thesis.seal.seal.Literal
import unifi.marcotinacci.thesis.seal.seal.Minus
import unifi.marcotinacci.thesis.seal.seal.ModuleDefine
import unifi.marcotinacci.thesis.seal.seal.Multi
import unifi.marcotinacci.thesis.seal.seal.Neq
import unifi.marcotinacci.thesis.seal.seal.NoAction
import unifi.marcotinacci.thesis.seal.seal.Not
import unifi.marcotinacci.thesis.seal.seal.Or
import unifi.marcotinacci.thesis.seal.seal.Plus
import unifi.marcotinacci.thesis.seal.seal.Program
import unifi.marcotinacci.thesis.seal.seal.Quantifier
import unifi.marcotinacci.thesis.seal.seal.QuantifierReference
import unifi.marcotinacci.thesis.seal.seal.Rule
import unifi.marcotinacci.thesis.seal.seal.VariableDeclaration

class SealGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(Program p : resource.contents.filter(typeof(Program))){
			// TODO preprocessing sugar
			fsa.generateFile("model.pm", p.prismCompile)
			fsa.generateFile("model.pctl", p.pctlCompile);
			fsa.generateFile("module.cpp", p.cppCompile)
		}
	}
	def pctlCompile(Program program) {
		'''
		
		'''
	}

	
	def cppCompile(Program program)
	// STUB
	'''
	#include <iostream>
	using namespace std;
	void main()
	{
		cout << "Hello World!" << endl;
	}
	'''
	
	def prismCompile(Program p)
	'''
	mdp
	
	// === CONSTANTS ===
	// TODO
		
	// === MODULES ===
	«FOR m:p.modules»
		«m.prismCompile»
	«ENDFOR»
	
	// === SYSTEM ===
	
	'''
	
	def prismCompile(ModuleDefine m)
	'''
	module «m.name»
	// variables
	«FOR v:m.variables»
		«v.prismCompile»
	«ENDFOR»
	// rules
	«FOR r:m.rules»
		«r.prismCompile»
	«ENDFOR»
	endmodule
	
	'''

	def prismCompile(VariableDeclaration v){
		var from = 0
		var to = 1
		var delta = 1
		
		for(r:(v.eContainer.eContainer as Program).ranges){
			if(r.variable==v){
				to = Integer::parseInt(r.to)
				from = Integer::parseInt(r.from)
				if(r.delta != null){
					delta = Integer::parseInt(r.delta)
				}
			}
		}		
		
		'''«v.name» : «IF v.type.name.equals('bool')»bool init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('int')»[«from»..«to»] init «v.expr.prismCompileExpression»;«ENDIF»«IF v.type.name.equals('float')»[0..floor((«to»-«from»)/«delta»)] init ceil((«v.expr.prismCompileExpression»-«from»)/«delta»);«ENDIF»'''
	}

	def prismCompile(Rule r)
	'''[«r.action.name»] «r.cond.prismCompileExpression» -> 
	«FOR c:r.cases SEPARATOR '+' AFTER ';'»
	(«c.weight.prismCompileExpression»)/(«r.totalWeight») : 
	«FOR u:c.update SEPARATOR '&'»
	«u.prismCompileUpdate»
	«ENDFOR»
	«ENDFOR»
	'''
	
	// TODO calcolare l'espressione concatenata solo una volta
	def totalWeight(Rule r)
	'''«FOR c:r.cases SEPARATOR '+'»(«c.weight.prismCompileExpression»)«ENDFOR»'''
	
	def dispatch prismCompileUpdate (NoAction n) 
	'''true'''

	def dispatch prismCompileUpdate (Assign a)
	'''(«a.variable.name»'=«a.expr.prismCompileExpression»)'''

	def dispatch prismCompileExpression(And e)
	'''(«e.left.prismCompileExpression» & «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Or e)
	'''(«e.left.prismCompileExpression» | «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Not e)
	'''!(«e.cond.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Leq e)	
	'''(«e.left.prismCompileExpression» <= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Less e)
	'''(«e.left.prismCompileExpression» < «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Geq e)	
	'''(«e.left.prismCompileExpression» >= «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Gtr e)
	'''(«e.left.prismCompileExpression» > «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Eq e)
	'''(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Neq e)
	'''!(«e.left.prismCompileExpression» = «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Plus e)	
	'''(«e.left.prismCompileExpression» + «e.right.prismCompileExpression»)'''

	def dispatch prismCompileExpression(Minus e)
	'''(«e.left.prismCompileExpression» - «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Multi e)
	'''(«e.left.prismCompileExpression» * «e.right.prismCompileExpression»)'''
	
	def dispatch prismCompileExpression(Div e)
	'''(«e.left.prismCompileExpression» / «e.right.prismCompileExpression»)'''

	// TODO
	def dispatch prismCompileExpression(QuantifierReference e)
	'''TODO'''

	// TODO
	def dispatch prismCompileExpression(Literal e){
		e.value
	}
	
	// TODO
	def dispatch prismCompileExpression(Quantifier e)
	'''TODO'''

}

